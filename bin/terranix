#!/usr/bin/env bash
set -e -o pipefail

# Exit codes
# - 1  no instance with name
# - 2  no config with name
# - 3  no configurator for provider
# - 4  config build failed
# - 5  not a valid config closure
# - 6  no state file found
# - 7  no deploy file (terranix.nix) found

BIN_DIR=$(cd "${BASH_SOURCE[0]%/*}"; pwd)
LIB_DIR="${BIN_DIR%/*}/lib"
TN_CONFIGURATOR_PATH="${TN_CONFIGURATOR_PATH-./.terranix/configurators:$LIB_DIR/configurators}"

_remote() {
  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@"$1" "${@:2}"
}

_configuratorPath() {
  PATH="$TN_CONFIGURATOR_PATH" command -v "${1:-default}"
}

_infect() {
  _remote "$1" bash /dev/stdin "${@:2}" < "$LIB_DIR"/infect
}

_configure() {
  _remote "$2" bash < "$(_configuratorPath "$1")"
}

_instance() {
  state | jq -r ".\"$1\" | .$2 // \"\""
}

_configs() {
  [ -f "./terranix.nix" ] \
    || { echo >&2 "Error: no deploy file (terranix.nix) found"; return 7; }
  nix-instantiate --eval-only --json -E 'builtins.attrNames (import ./terranix.nix)' \
    | jq -r '.[]'
}

_checkInstance() {
  local name

  name=$(_instance "$1") || return $?
  [ -n "$name" ] || { echo >&2 "Error: no instance with name: $1"; return 1; }
}

_checkInstances() {
  local names
  local names_

  if [ "$*" ]; then
    names=("$@")
  else
    names_=$(_configs) || return $?
    mapfile -t names <<<"$names_"
  fi
  for i in "${!names[@]}"; do
    _checkInstance "${names[$i]}" || return $?
    echo "${names[$i]}"
  done
}

_checkConfigurator() {
  [ -f "$(_configuratorPath "$1")" ] || {
    echo >&2 "Error: no configurator found for provider: $1"; return 3
  }
}

_initInstance() {
  local name
  local ip
  local provider
  local confPath
  local physical_nix

  name="$1"
  _checkInstance "$name"

  provider=$(_instance "$name" provider)
  _checkConfigurator "$provider"

  ip=$(_instance "$name" ip)
  confPath=".terranix/configuration-$name.nix"

  echo >&2 "Initializing config for: $name"

  # Get instance specific config
  physical_nix=$(_configure "$provider" "$ip") || return $?

  # Aggrigate instance config with custom configs
  mkdir -p .terranix
  cat > "$confPath" <<EOF
{ lib, ... }: let
  state = lib.importJSON ../terranix-state.json;
in {
  imports = [
    (${physical_nix})
    (import ../terranix.nix)."$name"
  ];
  options = with lib; with types; {
    terranix = mkOption {
      type = attrsOf (submodule { options = {
        name = mkOption { type = str; };
        ip = mkOption { type = str; };
        provider  = mkOption { type = str; default = "default"; };
        authorized_keys = mkOption { type = listOf str; default = []; };
        meta = mkOption { type = attrs; default = {}; };
      }; });
      default = {};
    };
  };
  config = {
    terranix = state;
    boot.cleanTmpDir = true;
    networking.hostName = "${name}";
    networking.firewall.allowPing = true;
    services.openssh.enable = true;
    users.users.root.openssh.authorizedKeys.keys = state."${name}".authorized_keys;
    system.activationScripts.nixos-cleanup = "rm -rf /old-root /boot.bak";
  };
}
EOF
  echo "$confPath"
}

_buildInstance() {
  local name="$1"
  _checkInstance "$name"
  local confPath="./.terranix/configuration-$name.nix"

  echo >&2 "Building config for: $name"

  # Build config
  nix-build --no-out-link '<nixpkgs/nixos>' -A system \
    --arg configuration "$confPath"
}

_pushInstance() {
  local name
  local ip
  local provider
  local path

  name="$1"
  _checkInstance "$name"
  ip=$(_instance "$name" ip)

  path="$2"
  [ -e "$path" ] || { echo >&2 "Error: not a valid config closure: $path"; return 5; }

  echo >&2 "Pushing config to: $name"

  # Install Nix if not already installed
  _infect "$ip" sourceNix

  # Push config closure to instance
  NIX_SSHOPTS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no PATH=/root/.nix-profile/bin:\$PATH" \
    nix-copy-closure --to root@"$ip" "$path"

  # Install config and infect instance with NixOS if not already
  _infect "$ip" switch "$name" "$path"
}

# CLI commands

terraformState() {
  jq -rM '
    [ .modules[].outputs
    | select(.name!=null and .ip!=null and .authorized_keys!=null)
    | { (.name.value): {
        name:.name.value,
        ip:.ip.value,
        provider:.provider.value,
        authorized_keys:.authorized_keys.value,
        meta: (to_entries
          | map(select(.key | test("^(name|ip|authorized_keys|provider)$") | not))
          | map({ (.key): .value.value })
          | add // {} )
      } }
    ] | add // {}
    ' "${TERRAFORM_STATE:-./terraform.tfstate}"
}

initFromTerraform() {
  terraformState > ./terranix-state.json
  init
}

state() {
  [ -f "./terranix-state.json" ] \
    || { echo >&2 "Error: no state file found"; return 6; }
  cat ./terranix-state.json
}

init() {
  local instances

  instances=$(_checkInstances) || return $?
  while read -r name; do
    _initInstance "$name"
  done <<<"$instances"
}

build() {
  local path
  local instances

  instances=$(_checkInstances "$@") || return $?
  while read -r name; do
    path=$(_buildInstance "$name") || {
      echo >&2 "Error: failed to build config for: $name"; return 4
    }
    echo "{\"name\":\"$name\",\"path\":\"$path\"}"
  done <<<"$instances"
}

push() {
  local name
  local path
  local buildOutput

  buildOutput=$(build "$@") || return $?
  while read -r buildInfo; do
    name=$(jq -r .name <<<"$buildInfo")
    path=$(jq -r .path <<<"$buildInfo")
    # If exit code is 4 keep pushing
    _pushInstance "$name" "$path" || [ "$?" == 4 ]
  done <<<"$buildOutput"
}

[ -z "$*" ] || "${1#_}" "${@:2}"
