#!/usr/bin/env bash
set -e -o pipefail

# Exit codes:
#   1  no instance with name
#   2  no config with name
#   3  no configurator for provider
#   4  config build failed
#   5  not a valid config closure
#   6  no input file found
#   7  no deploy file (terranix.nix) found
#   8  config push failed
#   9  couldn't reach instance
#  10  no instance with name

help() {
  cat >&2 <<EOF
Usage: terranix COMMAND [ARGS]

Commands:

  init NAMES..          Create input from Terraform state
  initFromJSON NAMES..  Create input from ./terranix-input.json
  input JSON_PATH       Print input data
  check NAMES..         Check reach-ability of nodes
  build NAMES..         Build configurations
  push NAMES..          Push configurations to nodes
  help                  This message
EOF
}

_usage() { printf >&2 "Error: %s\n\n" "$*"; help; exit 10; }

BIN_DIR=$(cd "${BASH_SOURCE[0]%/*}"; pwd)
LIB_DIR="${BIN_DIR%/*}/lib"
TN_CONFIGURATOR_PATH="${TN_CONFIGURATOR_PATH-./.terranix/configurators:$LIB_DIR/configurators}"
TN_SSH_OPTS="-o LogLevel=ERROR -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

_ilog() { sed "s|^|$1> |" >&2; }

_remote() {
  # shellcheck disable=SC2086 disable=SC2029
  ssh $TN_SSH_OPTS root@"$1" "${@:2}"
}

_configuratorPath() {
  PATH="$TN_CONFIGURATOR_PATH" command -v "${1:-default}"
}

_infect() {
  _remote "$1" bash /dev/stdin "${@:2}" < "$LIB_DIR"/infect
}

_configure() {
  _remote "$2" bash < "$(_configuratorPath "$1")"
}

_instance() {
  # shellcheck disable=SC2119
  input | jq -r ".nodes.\"$1\" | .$2 // \"\""
}

_configs() {
  [ -f "./terranix.nix" ] \
    || { echo >&2 "Error: No deploy file (terranix.nix) found"; return 7; }
  nix-instantiate --eval-only --json -E 'with import <nixpkgs> {};builtins.attrNames (import ./terranix.nix (import ./.terranix/input-transform.nix {inherit lib;}))' \
    | jq -r '.[]'
}

_checkInstance() {
  local name

  name=$(_instance "$1") || return $?
  [ -n "$name" ] || { echo >&2 "Error: No instance with name: $1"; return 1; }
}

_checkInstances() {
  local names
  local names_

  if [ -n "$*" ]
    then names=("$@")
    else names_=$(_configs) || return $?; mapfile -t names < <(echo "$names_")
  fi
  for i in "${!names[@]}"; do
    _checkInstance "${names[i]}" || return $?
    echo "${names[i]}"
  done
}

_checkConfigurator() {
  [ -f "$(_configuratorPath "$1")" ] || {
    echo >&2 "Error: No configurator found for provider: $1"; return 3
  }
}

_checkUp() {
  local ip

  ip=$(_instance "$1" ip)
  echo >&2 "Checking SSH connection..."
  for i in $(seq 3); do
    _remote "$ip" true && return 0 || echo >&2 "Info: SSH connection failed, try $i/3"
    sleep 5
  done
  echo >&2 "Error: Couldn't connect over SSH"
  return 1
}

_initInstance() {
  local name
  local ip
  local provider
  local confPath
  local physical_nix

  name="$1"
  _checkInstance "$name"

  provider=$(_instance "$name" provider)
  _checkConfigurator "$provider" || return $?

  ip=$(_instance "$name" ip)
  confPath="./.terranix/configuration-$name.nix"

  echo >&2 "Initializing config..."

  # Get instance specific config
  physical_nix=$(_configure "$provider" "$ip") || return $?

  # Aggrigate instance config with custom configs
  mkdir -p .terranix
  cat > "$confPath" <<EOF
{ lib, ... }: let
  input = import ./input-transform.nix { inherit lib; };
  node = input.nodes."${name}";
in {
  _module.args = { inherit input node; };
  require = [
    (${physical_nix})
    (import ../terranix.nix input)."$name"
  ];
  networking.hostName = "${name}";
  services.openssh.enable = true;
  users.users.root.openssh.authorizedKeys.keys = [node.ssh_key];
  system.activationScripts.nixos-cleanup = "rm -rf /old-root /boot.bak || true";
}
EOF
  echo "$name" "$confPath"
}

_buildInstance() {
  local name="$1"
  _checkInstance "$name"
  local confPath="./.terranix/configuration-$name.nix"

  echo >&2 "Building config..."

  # Build config
  # shellcheck disable=SC2086
  nix-build $NIX_OPTS --no-out-link '<nixpkgs/nixos>' -A system \
    --arg configuration "$confPath"
}

_pushInstance() {
  local name
  local ip
  local provider
  local path

  name="$1"
  _checkInstance "$name"
  ip=$(_instance "$name" ip)

  path="$2"
  [ -e "$path" ] || { echo >&2 "Error: Not a valid config closure: $path"; return 5; }

  echo >&2 "Pushing config..."

  # XXX: move groupadd to lib/infect
  # Install Nix if not already installed
  _infect "$ip" hasNix || {
    cat <(cat <<EOF
mkdir -m 0755 /nix
groupadd nixbld -g 30000 || true
for i in {1..10}; do
  useradd -c "Nix build user $i" \
    -d /var/empty -g nixbld -G nixbld \
    -M -N -r -s "$(command -v nologin)" nixbld$i \
  || true
done
EOF
    ) "$LIB_DIR"/install-nix-2.3 | _remote "$ip" sh
  }

  # Push config closure to instance
  NIX_SSHOPTS="$TN_SSH_OPTS PATH=/root/.nix-profile/bin:\$PATH" \
    nix-copy-closure --to root@"$ip" "$path"

  # Install config and infect instance with NixOS if not already
  _infect "$ip" switch "$path" || {
    case "$?" in
      100)
        echo >&2 "Rebooting..."
        _remote "$ip" reboot || true
        ;;
      4)
        echo >&2 "Warning: Couldn't start all services"
        ;;
      *)
        return 8
        ;;
    esac
  }
}

_init() {
  local instances

  instances=$(_checkInstances "$@") || return $?
  check "$@" || return $?
  while read -r name; do
    _initInstance "$name" \
      2> >(_ilog "$name")
  done <<<"$instances"
}

# CLI commands

init() {
  mkdir -p .terranix
  cat > .terranix/input-transform.nix <<EOF
{ lib, ... }: with builtins; with lib; let
  requiredKeys = [ "name" "ip" "ssh_key" ];
  getRoot = s: (
    if s?modules
    then (findFirst
      (m: (length m.path) == 1 && (elemAt m.path 0) == "root")
      {outputs={};} s.modules)
    else s
  ).outputs;
  values = _: v: v.value;
  isNode = m: all (k: elem k (attrNames m)) requiredKeys;
  getNodes = m: flatten (optional (m?terranix) m.terranix);

  tfstate = importJSON ../terraform.tfstate;
  outputs = mapAttrs values (getRoot tfstate);
  nodes = filter (isNode) (getNodes outputs);
in {
  meta = removeAttrs outputs ["terranix"];
  nodes = listToAttrs (map (m: { name = m.name; value = m; }) nodes);
}
EOF
  _init "$@"
}

initFromJSON() {
  [ -f ./terranix-input.json ] \
    || { echo >&2 "Error: Couldn't find input JSON at $PWD/terranix-input.json"; return 6; }
  mkdir -p .terranix
  cat > .terranix/input-transform.nix <<EOF
{ lib, ... }: lib.importJSON ../terranix-input.json;
EOF
  _init "$@"
}

# shellcheck disable=SC2120
input() {
  [ -f ./.terranix/input-transform.nix ] \
    || { echo >&2 "Error: Couldn't find input transform, try running: terranix init"; return 6; }
  nix-instantiate --eval-only --strict --json \
    -E 'with import <nixpkgs> {};import ./.terranix/input-transform.nix {inherit lib;}' \
    | jq -rM ".$1 // \"\"" \
    || { echo >&2 "Error: Input transform failed"; return 6; }
}

check() {
  local instances
  local ecode; ecode=0

  instances=$(_checkInstances "$@") || return $?
  while read -r name; do
    _checkUp "$name" \
      2> >(_ilog "$name") \
      || { ecode=9; continue; }
  done <<<"$instances"
  [ "$ecode" == 0 ] || echo >&2 "Error: Couldn't reach all instance"
  return $ecode
}

build() {
  local path
  local instances

  instances=$(_checkInstances "$@") || return $?
  while read -r name; do
    { path=$(_buildInstance "$name") || {
        echo >&2 "Error: Failed to build config"; return 4
      }
    } 2> >(_ilog "$name")
    echo "$name" "$path"
  done <<<"$instances"
}

push() {
  local name
  local path
  local buildOutput

  buildOutput=$(build "$@") || return $?
  check "$@" || return $?
  while read -r name path; do
    _pushInstance "$name" "$path" \
      2> >(_ilog "$name")
  done <<<"$buildOutput"
  check "$@" || return $?
}

trap 'trap - TERM; kill $$' TERM

cmd=${1:-help}
declare -F | cut -d' ' -f3 | grep -q "^${cmd#_}$" \
  || _usage "No command: $cmd"

"${cmd#_}" "${@:2}" && printf "\nDone!" >&2
